<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>rust on heroku with hyper http</title>
    <link rel="stylesheet" href="https://dhbhdrzi4tiry.cloudfront.net/cdn/sites/foundation.min.css">
  </head>
  <body>

    <!-- Start Top Bar -->
    <div class="top-bar">
      <div class="top-bar-left">
        <ul class="menu">
          <li class="menu-text">The evolving ultrasaurus</li>
        </ul>
      </div>
      <div class="top-bar-right">
        <ul class="menu">
          <li><a href="/about">About</a></li>
          <li><a href="/speaking">Speaking</a></li>
          <li><a href="/contact">Contact</a></li>
          <li><a href="/ultrasaurus">What's an ultrasaurus?</a></li>
        </ul>
      </div>
    </div>
    <!-- End Top Bar -->

    <div class="row" id="content">
      <div class="medium-8 columns">
        
<h1>rust on heroku with hyper http</h1>

<p>Running an app on heroku requires at least one entry point responding to http. An easy way to do this is to use <a href="hyper.rs">hyper</a> to create a simple web service.</p>
<h2>Setup</h2>
<pre><code>cargo new hello_rust --bin
cd hello_rust
git init
git add .
git commit -m &quot;cargo new hello_rust --bin&quot;

</code></pre>
<p>add to <code>Cargo.toml</code>:</p>
<pre><code>[dependencies]
hyper = &quot;0.13&quot;

</code></pre>
<h2>Web service code</h2>
<p>The core code to set up a little web service has a few key parts:</p>
<ol>
<li>the service (<code>async fn hello</code>)</li>
</ol>
<ul>
<li>an async function that takes a <code>hyper::Request</code> and returns a <code>hyper::Response</code> in the <code>Result</code></li>
<li><a href="https://docs.rs/hyper/0.13.1/hyper/struct.Request.html">Request</a> is generic over the Body, so it seems nifty to be able to provide our own Rust types for specific content (like JSON) and also for validating API POST params</li>
<li>Result is <a href="https://doc.rust-lang.org/std/convert/enum.Infallible.html">Infallible</a>: a Rust error type signifying that the function never returns an error</li>
</ul>
<ol start="2">
<li><a href="https://docs.rs/hyper/0.13.1/hyper/service/fn.make_service_fn.html">make_service_fn</a> — docs are a bit sparse on this, but I think all it does it generate an instance of the service with the Request context that so that each request can run concurrently</li>
<li>Server::bind(&amp;addr).serve(…) — Hyper uses a builder pattern where Server::bind generates a <a href="https://docs.rs/hyper/0.13.1/hyper/server/struct.Builder.html">Builder</a>, where you can configure http1/2 support and then a running instance of the Server is created by calling the <a href="https://docs.rs/hyper/0.13.1/hyper/server/struct.Builder.html#method.serve">serve method</a> with the service function.</li>
</ol>
<p>To see this in action, replace <code>main.rs</code> with this code:</p>
<pre><code>use hyper::service::{make_service_fn, service_fn};
use hyper::{Body, Request, Response, Server};
use std::convert::Infallible;

async fn hello(_req: Request&lt;Body&gt;) -&gt; Result&lt;Response&lt;Body&gt;, Infallible&gt; {
    Ok(Response::new(Body::from(
        &quot;&lt;HTML&gt;&lt;H1&gt;Hello World!&lt;/H1&gt;&lt;HTML&gt;&quot;,
    )))
}

#[tokio::main]
pub async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {

    let make_svc = make_service_fn(|_conn| {
        async { Ok::&lt;_, Infallible&gt;(service_fn(hello)) }
    });

    let addr = ([0, 0, 0, 0], 3000).into();

    let server = Server::bind(&amp;addr).serve(make_svc);

    println!(&quot;Listening on {}&quot;, addr);

    server.await?;

    Ok(())
}

</code></pre>
<p>to run the app locally:</p>
<pre><code>cargo run

</code></pre>
<p>then in the browser, go to <a href="http://localhost:3000/">http://localhost:3000/</a></p>
<h2>Heroku setup</h2>
<h3>1. Heroku CLI</h3>
<p>Install <a href="https://devcenter.heroku.com/articles/heroku-cli">heroku CLI</a> or if you already have it:</p>
<p><code>heroku update</code></p>
<p>Then to set up the app on heroku:</p>
<pre><code>heroku create --buildpack emk/rust

</code></pre>
<h3>2. Procfile</h3>
<p>Add a Procfile for heroku to know what to call when it receives a web request:</p>
<pre><code>echo &quot;web: ./target/release/hello_rust&quot; &gt;&gt; Procfile

</code></pre>
<h3>3. Port configuration</h3>
<p>Heroku requires that we listen on the port specified with the <code>PORT</code> env var. So, add the following code and replace the hard-coded port number with this variable:</p>
<pre><code>    let port = env::var(&quot;PORT&quot;)
        .unwrap_or_else(|_| &quot;3000&quot;.to_string())
        .parse()
        .expect(&quot;PORT must be a number&quot;);

</code></pre>
<h3>4. Deploy!</h3>
<p>Deploy the app by pushing code to the Heroku remote repository that was set up by the CLI in step 1.</p>
<pre><code> git push heroku master

</code></pre>
<p>Full code for the app is on <a href="https://github.com/ultrasaurus/hello-heroku-rust/tree/hyper">github.com/ultrasaurus/hello-heroku-rust</a></p>
<h2>Background</h2>
<p>My environment info (<code>rustup show</code>):</p>
<pre><code>stable-x86_64-apple-darwin (default)
rustc 1.39.0 (4560ea788 2019-11-04)

</code></pre>

<hr>
<ul><li>Next: <a href="/2020/01/writing-c-library-in-rust/">writing c library in rust</a></li><li>Previous: <a href="/2020/01/rust-on-heroku-with-async-await-and-tokio/">rust on heroku with async/await and tokio</a></li>
</ul>

      </div>
      <div class="medium-3 columns" data-sticky-container>
        <div class="sticky" data-sticky data-anchor="content">
          <h4>Categories</h4>
          <ul>
            <li><a href="#">Skyler</a></li>
            <li><a href="#">Jesse</a></li>
            <li><a href="#">Mike</a></li>
            <li><a href="#">Holly</a></li>
          </ul>
        </div>
      </div>
    </div>

    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="https://dhbhdrzi4tiry.cloudfront.net/cdn/sites/foundation.js"></script>
    <script>
      $(document).foundation();
    </script>
  </body>
</html>



